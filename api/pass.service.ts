/**
 * Demo Client for Passmeister Apple Wallet and Google Wallet API
 * [www.passmeister.com](https://www.passmeister.com).
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';


import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class PassService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes.
     * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes.
     * @param passTypeId your pass type id, for example P963493 (Urban Fitness)
     * @param passId id of the pass (provided by you when creating the pass or automatically set by passmeister)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdatePass(passTypeId: any, passId?: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createOrUpdatePass(passTypeId: any, passId?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createOrUpdatePass(passTypeId: any, passId?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createOrUpdatePass(passTypeId: any, passId?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passTypeId === null || passTypeId === undefined) {
            throw new Error('Required parameter passTypeId was null or undefined when calling createOrUpdatePass.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passTypeId !== undefined && passTypeId !== null) {
            queryParameters = queryParameters.set('passTypeId', <any>passTypeId);
        }
        if (passId !== undefined && passId !== null) {
            queryParameters = queryParameters.set('passId', <any>passId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/pass`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete pass by pass id.
     * Delete pass by pass id.
     * @param passTypeId your pass type id, for example P963493 (Urban Fitness)
     * @param passId id of the pass
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePass(passTypeId: any, passId: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deletePass(passTypeId: any, passId: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deletePass(passTypeId: any, passId: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deletePass(passTypeId: any, passId: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passTypeId === null || passTypeId === undefined) {
            throw new Error('Required parameter passTypeId was null or undefined when calling deletePass.');
        }

        if (passId === null || passId === undefined) {
            throw new Error('Required parameter passId was null or undefined when calling deletePass.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passTypeId !== undefined && passTypeId !== null) {
            queryParameters = queryParameters.set('passTypeId', <any>passTypeId);
        }
        if (passId !== undefined && passId !== null) {
            queryParameters = queryParameters.set('passId', <any>passId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/pass`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get pass information by pass id.
     * Get pass information by pass id.
     * @param passTypeId your pass type id, for example P963493 (Urban Fitness)
     * @param passId id of the pass
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPass(passTypeId: any, passId: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getPass(passTypeId: any, passId: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getPass(passTypeId: any, passId: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getPass(passTypeId: any, passId: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passTypeId === null || passTypeId === undefined) {
            throw new Error('Required parameter passTypeId was null or undefined when calling getPass.');
        }

        if (passId === null || passId === undefined) {
            throw new Error('Required parameter passId was null or undefined when calling getPass.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passTypeId !== undefined && passTypeId !== null) {
            queryParameters = queryParameters.set('passTypeId', <any>passTypeId);
        }
        if (passId !== undefined && passId !== null) {
            queryParameters = queryParameters.set('passId', <any>passId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/pass`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the list of active pass ids for a given pass type.
     * Retrieve the list of active pass ids for a given pass type.
     * @param passTypeId your pass type id, for example P963493 (Urban Fitness)
     * @param page 
     * @param limit 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public passList(passTypeId: any, page?: any, limit?: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public passList(passTypeId: any, page?: any, limit?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public passList(passTypeId: any, page?: any, limit?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public passList(passTypeId: any, page?: any, limit?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passTypeId === null || passTypeId === undefined) {
            throw new Error('Required parameter passTypeId was null or undefined when calling passList.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passTypeId !== undefined && passTypeId !== null) {
            queryParameters = queryParameters.set('passTypeId', <any>passTypeId);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/pass/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send updates to all active passes for a given pass type.
     * For example: you changed the pass type layout and now you want to update all installed passes. (The API call only confirms the scheduling of the updates, actual updating of passes on your customers devices can take a while.)
     * @param passTypeId your pass type id, for example P963493 (Urban Fitness)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public passSync(passTypeId: any, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public passSync(passTypeId: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public passSync(passTypeId: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public passSync(passTypeId: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passTypeId === null || passTypeId === undefined) {
            throw new Error('Required parameter passTypeId was null or undefined when calling passSync.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passTypeId !== undefined && passTypeId !== null) {
            queryParameters = queryParameters.set('passTypeId', <any>passTypeId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/pass/sync`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
